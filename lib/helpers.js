"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lintCallExpression = lintCallExpression;
exports.lintNewExpression = lintNewExpression;
exports.lintExpressionStatement = lintExpressionStatement;
exports.lintMemberExpression = lintMemberExpression;
exports.reverseTargetMappings = reverseTargetMappings;
exports.determineTargetsFromConfig = determineTargetsFromConfig;
exports.parseBrowsersListVersion = parseBrowsersListVersion;

require("core-js/modules/es.object.from-entries.js");

require("core-js/modules/es.array.sort.js");

var _browserslist = _interopRequireDefault(require("browserslist"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-nested-ternary: off */

/*
3) Figures out which browsers user is targeting

- Uses browserslist config and/or targets defined eslint config to discover this
- For every API ecnountered during traversal, gets compat record for that
- Protochain (e.g. 'document.querySelector')
  - All of the rules have compatibility info attached to them
- Each API is given to versioning.ts with compatibility info
*/
function isInsideIfStatement(context) {
  return context.getAncestors().some(ancestor => {
    return ancestor.type === "IfStatement";
  });
}

function checkNotInsideIfStatementAndReport(context, handleFailingRule, failingRule, node) {
  // if (!isInsideIfStatement(context)) {
  handleFailingRule(failingRule, node); // }
}

function lintCallExpression(context, handleFailingRule, rules, node) {
  if (!node.callee) return;
  const calleeName = node.callee.name;
  const failingRule = rules.find(rule => rule.object === calleeName);
  if (failingRule) checkNotInsideIfStatementAndReport(context, handleFailingRule, failingRule, node);
}

function lintNewExpression(context, handleFailingRule, rules, node) {
  if (!node.callee) return;
  const calleeName = node.callee.name;
  const failingRule = rules.find(rule => rule.object === calleeName);
  if (failingRule) checkNotInsideIfStatementAndReport(context, handleFailingRule, failingRule, node);
}

function lintExpressionStatement(context, handleFailingRule, rules, node) {
  var _node$expression;

  if (!(node !== null && node !== void 0 && (_node$expression = node.expression) !== null && _node$expression !== void 0 && _node$expression.name)) return;
  const failingRule = rules.find(rule => {
    var _node$expression2;

    return rule.object === (node === null || node === void 0 ? void 0 : (_node$expression2 = node.expression) === null || _node$expression2 === void 0 ? void 0 : _node$expression2.name);
  });
  if (failingRule) checkNotInsideIfStatementAndReport(context, handleFailingRule, failingRule, node);
}

function protoChainFromMemberExpression(node) {
  if (!node.object) return [node.name];

  const protoChain = (() => {
    switch (node.object.type) {
      case "NewExpression":
      case "CallExpression":
        return protoChainFromMemberExpression(node.object.callee);

      default:
        return protoChainFromMemberExpression(node.object);
    }
  })();

  return [...protoChain, node.property.name];
}

function lintMemberExpression(context, handleFailingRule, rules, node) {
  if (!node.object || !node.property) return;

  if (!node.object.name || node.object.name === "window" || node.object.name === "globalThis") {
    const rawProtoChain = protoChainFromMemberExpression(node);
    const [firstObj] = rawProtoChain;
    const protoChain = firstObj === "window" || firstObj === "globalThis" ? rawProtoChain.slice(1) : rawProtoChain;
    const protoChainId = protoChain.join(".");
    const failingRule = rules.find(rule => rule.protoChainId === protoChainId);

    if (failingRule) {
      checkNotInsideIfStatementAndReport(context, handleFailingRule, failingRule, node);
    }
  } else {
    const objectName = node.object.name;
    const propertyName = node.property.name;
    const failingRule = rules.find(rule => rule.object === objectName && (rule.property == null || rule.property === propertyName));
    if (failingRule) checkNotInsideIfStatementAndReport(context, handleFailingRule, failingRule, node);
  }
}

function reverseTargetMappings(targetMappings) {
  const reversedEntries = Object.entries(targetMappings).map(entry => entry.reverse());
  return Object.fromEntries(reversedEntries);
}
/**
 * Determine the targets based on the browserslist config object
 * Get the targets from the eslint config and merge them with targets in browserslist config
 * Eslint target config will be deprecated in 4.0.0
 *
 * @param configPath - The file or a directory path to look for the browserslist config file
 */


function determineTargetsFromConfig(configPath, config) {
  const browserslistOpts = {
    path: configPath
  };

  const eslintTargets = (() => {
    // Get targets from eslint settings
    if (Array.isArray(config) || typeof config === "string") {
      return (0, _browserslist.default)(config, browserslistOpts);
    }

    if (config && typeof config === "object") {
      return (0, _browserslist.default)([...(config.production || []), ...(config.development || [])], browserslistOpts);
    }

    return [];
  })();

  if (_browserslist.default.findConfig(configPath)) {
    // If targets are defined in ESLint and browerslist configs, merge the targets together
    if (eslintTargets.length) {
      const browserslistTargets = (0, _browserslist.default)(undefined, browserslistOpts);
      return Array.from(new Set(eslintTargets.concat(browserslistTargets)));
    }
  } else if (eslintTargets.length) {
    return eslintTargets;
  } // Get targets fron browserslist configs


  return (0, _browserslist.default)(undefined, browserslistOpts);
}
/**
 * Parses the versions that are given by browserslist. They're
 *
 * ```ts
 * parseBrowsersListVersion(['chrome 50'])
 *
 * {
 *   target: 'chrome',
 *   parsedVersion: 50,
 *   version: '50'
 * }
 * ```
 * @param targetslist - List of targest from browserslist api
 * @returns - The lowest version version of each target
 */


function parseBrowsersListVersion(targetslist) {
  return (// Sort the targets by target name and then version number in ascending order
    targetslist.map(e => {
      const [target, version] = e.split(" ");

      const parsedVersion = (() => {
        if (typeof version === "number") return version;
        if (version === "all") return 0;
        return version.includes("-") ? parseFloat(version.split("-")[0]) : parseFloat(version);
      })();

      return {
        target,
        version,
        parsedVersion
      };
    }) // Sort the targets by target name and then version number in descending order
    // ex. [a@3, b@3, a@1] => [a@3, a@1, b@3]
    .sort((a, b) => {
      if (b.target === a.target) {
        // If any version === 'all', return 0. The only version of op_mini is 'all'
        // Otherwise, compare the versions
        return typeof b.parsedVersion === "string" || typeof a.parsedVersion === "string" ? 0 : b.parsedVersion - a.parsedVersion;
      }

      return b.target > a.target ? 1 : -1;
    }) // First last target always has the latest version
    .filter((e, i, items) => // Check if the current target is the last of its kind.
    // If it is, then it's the most recent version.
    i + 1 === items.length || e.target !== items[i + 1].target)
  );
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbImlzSW5zaWRlSWZTdGF0ZW1lbnQiLCJjb250ZXh0IiwiZ2V0QW5jZXN0b3JzIiwic29tZSIsImFuY2VzdG9yIiwidHlwZSIsImNoZWNrTm90SW5zaWRlSWZTdGF0ZW1lbnRBbmRSZXBvcnQiLCJoYW5kbGVGYWlsaW5nUnVsZSIsImZhaWxpbmdSdWxlIiwibm9kZSIsImxpbnRDYWxsRXhwcmVzc2lvbiIsInJ1bGVzIiwiY2FsbGVlIiwiY2FsbGVlTmFtZSIsIm5hbWUiLCJmaW5kIiwicnVsZSIsIm9iamVjdCIsImxpbnROZXdFeHByZXNzaW9uIiwibGludEV4cHJlc3Npb25TdGF0ZW1lbnQiLCJleHByZXNzaW9uIiwicHJvdG9DaGFpbkZyb21NZW1iZXJFeHByZXNzaW9uIiwicHJvdG9DaGFpbiIsInByb3BlcnR5IiwibGludE1lbWJlckV4cHJlc3Npb24iLCJyYXdQcm90b0NoYWluIiwiZmlyc3RPYmoiLCJzbGljZSIsInByb3RvQ2hhaW5JZCIsImpvaW4iLCJvYmplY3ROYW1lIiwicHJvcGVydHlOYW1lIiwicmV2ZXJzZVRhcmdldE1hcHBpbmdzIiwidGFyZ2V0TWFwcGluZ3MiLCJyZXZlcnNlZEVudHJpZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJyZXZlcnNlIiwiZnJvbUVudHJpZXMiLCJkZXRlcm1pbmVUYXJnZXRzRnJvbUNvbmZpZyIsImNvbmZpZ1BhdGgiLCJjb25maWciLCJicm93c2Vyc2xpc3RPcHRzIiwicGF0aCIsImVzbGludFRhcmdldHMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9kdWN0aW9uIiwiZGV2ZWxvcG1lbnQiLCJicm93c2Vyc2xpc3QiLCJmaW5kQ29uZmlnIiwibGVuZ3RoIiwiYnJvd3NlcnNsaXN0VGFyZ2V0cyIsInVuZGVmaW5lZCIsImZyb20iLCJTZXQiLCJjb25jYXQiLCJwYXJzZUJyb3dzZXJzTGlzdFZlcnNpb24iLCJ0YXJnZXRzbGlzdCIsImUiLCJ0YXJnZXQiLCJ2ZXJzaW9uIiwic3BsaXQiLCJwYXJzZWRWZXJzaW9uIiwiaW5jbHVkZXMiLCJwYXJzZUZsb2F0Iiwic29ydCIsImEiLCJiIiwiZmlsdGVyIiwiaSIsIml0ZW1zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBOzs7O0FBREE7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0EsbUJBQVQsQ0FBNkJDLE9BQTdCLEVBQStDO0FBQzdDLFNBQU9BLE9BQU8sQ0FBQ0MsWUFBUixHQUF1QkMsSUFBdkIsQ0FBNkJDLFFBQUQsSUFBYztBQUMvQyxXQUFPQSxRQUFRLENBQUNDLElBQVQsS0FBa0IsYUFBekI7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFRCxTQUFTQyxrQ0FBVCxDQUNFTCxPQURGLEVBRUVNLGlCQUZGLEVBR0VDLFdBSEYsRUFJRUMsSUFKRixFQUtFO0FBQ0E7QUFDRUYsRUFBQUEsaUJBQWlCLENBQUNDLFdBQUQsRUFBY0MsSUFBZCxDQUFqQixDQUZGLENBR0E7QUFDRDs7QUFFTSxTQUFTQyxrQkFBVCxDQUNMVCxPQURLLEVBRUxNLGlCQUZLLEVBR0xJLEtBSEssRUFJTEYsSUFKSyxFQUtMO0FBQ0EsTUFBSSxDQUFDQSxJQUFJLENBQUNHLE1BQVYsRUFBa0I7QUFDbEIsUUFBTUMsVUFBVSxHQUFHSixJQUFJLENBQUNHLE1BQUwsQ0FBWUUsSUFBL0I7QUFDQSxRQUFNTixXQUFXLEdBQUdHLEtBQUssQ0FBQ0ksSUFBTixDQUFZQyxJQUFELElBQVVBLElBQUksQ0FBQ0MsTUFBTCxLQUFnQkosVUFBckMsQ0FBcEI7QUFDQSxNQUFJTCxXQUFKLEVBQ0VGLGtDQUFrQyxDQUNoQ0wsT0FEZ0MsRUFFaENNLGlCQUZnQyxFQUdoQ0MsV0FIZ0MsRUFJaENDLElBSmdDLENBQWxDO0FBTUg7O0FBRU0sU0FBU1MsaUJBQVQsQ0FDTGpCLE9BREssRUFFTE0saUJBRkssRUFHTEksS0FISyxFQUlMRixJQUpLLEVBS0w7QUFDQSxNQUFJ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bm8tbmVzdGVkLXRlcm5hcnk6IG9mZiAqL1xuaW1wb3J0IGJyb3dzZXJzbGlzdCBmcm9tIFwiYnJvd3NlcnNsaXN0XCI7XG5pbXBvcnQge1xuICBBc3RNZXRhZGF0YUFwaVdpdGhUYXJnZXRzUmVzb2x2ZXIsXG4gIEVTTGludE5vZGUsXG4gIEJyb3dzZXJMaXN0Q29uZmlnLFxuICBUYXJnZXQsXG4gIEhhbmRsZUZhaWxpbmdSdWxlLFxuICBDb250ZXh0LFxufSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgVGFyZ2V0TmFtZU1hcHBpbmdzIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qXG4zKSBGaWd1cmVzIG91dCB3aGljaCBicm93c2VycyB1c2VyIGlzIHRhcmdldGluZ1xuXG4tIFVzZXMgYnJvd3NlcnNsaXN0IGNvbmZpZyBhbmQvb3IgdGFyZ2V0cyBkZWZpbmVkIGVzbGludCBjb25maWcgdG8gZGlzY292ZXIgdGhpc1xuLSBGb3IgZXZlcnkgQVBJIGVjbm91bnRlcmVkIGR1cmluZyB0cmF2ZXJzYWwsIGdldHMgY29tcGF0IHJlY29yZCBmb3IgdGhhdFxuLSBQcm90b2NoYWluIChlLmcuICdkb2N1bWVudC5xdWVyeVNlbGVjdG9yJylcbiAgLSBBbGwgb2YgdGhlIHJ1bGVzIGhhdmUgY29tcGF0aWJpbGl0eSBpbmZvIGF0dGFjaGVkIHRvIHRoZW1cbi0gRWFjaCBBUEkgaXMgZ2l2ZW4gdG8gdmVyc2lvbmluZy50cyB3aXRoIGNvbXBhdGliaWxpdHkgaW5mb1xuKi9cbmZ1bmN0aW9uIGlzSW5zaWRlSWZTdGF0ZW1lbnQoY29udGV4dDogQ29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5nZXRBbmNlc3RvcnMoKS5zb21lKChhbmNlc3RvcikgPT4ge1xuICAgIHJldHVybiBhbmNlc3Rvci50eXBlID09PSBcIklmU3RhdGVtZW50XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja05vdEluc2lkZUlmU3RhdGVtZW50QW5kUmVwb3J0KFxuICBjb250ZXh0OiBDb250ZXh0LFxuICBoYW5kbGVGYWlsaW5nUnVsZTogSGFuZGxlRmFpbGluZ1J1bGUsXG4gIGZhaWxpbmdSdWxlOiBBc3RNZXRhZGF0YUFwaVdpdGhUYXJnZXRzUmVzb2x2ZXIsXG4gIG5vZGU6IEVTTGludE5vZGVcbikge1xuICAvLyBpZiAoIWlzSW5zaWRlSWZTdGF0ZW1lbnQoY29udGV4dCkpIHtcbiAgICBoYW5kbGVGYWlsaW5nUnVsZShmYWlsaW5nUnVsZSwgbm9kZSk7XG4gIC8vIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbnRDYWxsRXhwcmVzc2lvbihcbiAgY29udGV4dDogQ29udGV4dCxcbiAgaGFuZGxlRmFpbGluZ1J1bGU6IEhhbmRsZUZhaWxpbmdSdWxlLFxuICBydWxlczogQXN0TWV0YWRhdGFBcGlXaXRoVGFyZ2V0c1Jlc29sdmVyW10sXG4gIG5vZGU6IEVTTGludE5vZGVcbikge1xuICBpZiAoIW5vZGUuY2FsbGVlKSByZXR1cm47XG4gIGNvbnN0IGNhbGxlZU5hbWUgPSBub2RlLmNhbGxlZS5uYW1lO1xuICBjb25zdCBmYWlsaW5nUnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHJ1bGUub2JqZWN0ID09PSBjYWxsZWVOYW1lKTtcbiAgaWYgKGZhaWxpbmdSdWxlKVxuICAgIGNoZWNrTm90SW5zaWRlSWZTdGF0ZW1lbnRBbmRSZXBvcnQoXG4gICAgICBjb250ZXh0LFxuICAgICAgaGFuZGxlRmFpbGluZ1J1bGUsXG4gICAgICBmYWlsaW5nUnVsZSxcbiAgICAgIG5vZGVcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGludE5ld0V4cHJlc3Npb24oXG4gIGNvbnRleHQ6IENvbnRleHQsXG4gIGhhbmRsZUZhaWxpbmdSdWxlOiBIYW5kbGVGYWlsaW5nUnVsZSxcbiAgcnVsZXM6IEFycmF5PEFzdE1ldGFkYXRhQXBpV2l0aFRhcmdldHNSZXNvbHZlcj4sXG4gIG5vZGU6IEVTTGludE5vZGVcbikge1xuICBpZiAoIW5vZGUuY2FsbGVlKSByZXR1cm47XG4gIGNvbnN0IGNhbGxlZU5hbWUgPSBub2RlLmNhbGxlZS5uYW1lO1xuICBjb25zdCBmYWlsaW5nUnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHJ1bGUub2JqZWN0ID09PSBjYWxsZWVOYW1lKTtcbiAgaWYgKGZhaWxpbmdSdWxlKVxuICAgIGNoZWNrTm90SW5zaWRlSWZTdGF0ZW1lbnRBbmRSZXBvcnQoXG4gICAgICBjb250ZXh0LFxuICAgICAgaGFuZGxlRmFpbGluZ1J1bGUsXG4gICAgICBmYWlsaW5nUnVsZSxcbiAgICAgIG5vZGVcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGludEV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gIGNvbnRleHQ6IENvbnRleHQsXG4gIGhhbmRsZUZhaWxpbmdSdWxlOiBIYW5kbGVGYWlsaW5nUnVsZSxcbiAgcnVsZXM6IEFzdE1ldGFkYXRhQXBpV2l0aFRhcmdldHNSZXNvbHZlcltdLFxuICBub2RlOiBFU0xpbnROb2RlXG4pIHtcbiAgaWYgKCFub2RlPy5leHByZXNzaW9uPy5uYW1lKSByZXR1cm47XG4gIGNvbnN0IGZhaWxpbmdSdWxlID0gcnVsZXMuZmluZChcbiAgICAocnVsZSkgPT4gcnVsZS5vYmplY3QgPT09IG5vZGU/LmV4cHJlc3Npb24/Lm5hbWVcbiAgKTtcbiAgaWYgKGZhaWxpbmdSdWxlKVxuICAgIGNoZWNrTm90SW5zaWRlSWZTdGF0ZW1lbnRBbmRSZXBvcnQoXG4gICAgICBjb250ZXh0LFxuICAgICAgaGFuZGxlRmFpbGluZ1J1bGUsXG4gICAgICBmYWlsaW5nUnVsZSxcbiAgICAgIG5vZGVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBwcm90b0NoYWluRnJvbU1lbWJlckV4cHJlc3Npb24obm9kZTogRVNMaW50Tm9kZSk6IHN0cmluZ1tdIHtcbiAgaWYgKCFub2RlLm9iamVjdCkgcmV0dXJuIFtub2RlLm5hbWVdO1xuICBjb25zdCBwcm90b0NoYWluID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKG5vZGUub2JqZWN0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHByb3RvQ2hhaW5Gcm9tTWVtYmVyRXhwcmVzc2lvbihub2RlLm9iamVjdC5jYWxsZWUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHByb3RvQ2hhaW5Gcm9tTWVtYmVyRXhwcmVzc2lvbihub2RlLm9iamVjdCk7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4gWy4uLnByb3RvQ2hhaW4sIG5vZGUucHJvcGVydHkubmFtZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW50TWVtYmVyRXhwcmVzc2lvbihcbiAgY29udGV4dDogQ29udGV4dCxcbiAgaGFuZGxlRmFpbGluZ1J1bGU6IEhhbmRsZUZhaWxpbmdSdWxlLFxuICBydWxlczogQXJyYXk8QXN0TWV0YWRhdGFBcGlXaXRoVGFyZ2V0c1Jlc29sdmVyPixcbiAgbm9kZTogRVNMaW50Tm9kZVxuKSB7XG4gIGlmICghbm9kZS5vYmplY3QgfHwgIW5vZGUucHJvcGVydHkpIHJldHVybjtcbiAgaWYgKFxuICAgICFub2RlLm9iamVjdC5uYW1lIHx8XG4gICAgbm9kZS5vYmplY3QubmFtZSA9PT0gXCJ3aW5kb3dcIiB8fFxuICAgIG5vZGUub2JqZWN0Lm5hbWUgPT09IFwiZ2xvYmFsVGhpc1wiXG4gICkge1xuICAgIGNvbnN0IHJhd1Byb3RvQ2hhaW4gPSBwcm90b0NoYWluRnJvbU1lbWJlckV4cHJlc3Npb24obm9kZSk7XG4gICAgY29uc3QgW2ZpcnN0T2JqXSA9IHJhd1Byb3RvQ2hhaW47XG4gICAgY29uc3QgcHJvdG9DaGFpbiA9XG4gICAgICBmaXJzdE9iaiA9PT0gXCJ3aW5kb3dcIiB8fCBmaXJzdE9iaiA9PT0gXCJnbG9iYWxUaGlzXCJcbiAgICAgICAgPyByYXdQcm90b0NoYWluLnNsaWNlKDEpXG4gICAgICAgIDogcmF3UHJvdG9DaGFpbjtcbiAgICBjb25zdCBwcm90b0NoYWluSWQgPSBwcm90b0NoYWluLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IGZhaWxpbmdSdWxlID0gcnVsZXMuZmluZChcbiAgICAgIChydWxlKSA9PiBydWxlLnByb3RvQ2hhaW5JZCA9PT0gcHJvdG9DaGFpbklkXG4gICAgKTtcbiAgICBpZiAoZmFpbGluZ1J1bGUpIHtcbiAgICAgIGNoZWNrTm90SW5zaWRlSWZTdGF0ZW1lbnRBbmRSZXBvcnQoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICBmYWlsaW5nUnVsZSxcbiAgICAgICAgbm9kZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb2JqZWN0TmFtZSA9IG5vZGUub2JqZWN0Lm5hbWU7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gbm9kZS5wcm9wZXJ0eS5uYW1lO1xuICAgIGNvbnN0IGZhaWxpbmdSdWxlID0gcnVsZXMuZmluZChcbiAgICAgIChydWxlKSA9PlxuICAgICAgICBydWxlLm9iamVjdCA9PT0gb2JqZWN0TmFtZSAmJlxuICAgICAgICAocnVsZS5wcm9wZXJ0eSA9PSBudWxsIHx8IHJ1bGUucHJvcGVydHkgPT09IHByb3BlcnR5TmFtZSlcbiAgICApO1xuICAgIGlmIChmYWlsaW5nUnVsZSlcbiAgICAgIGNoZWNrTm90SW5zaWRlSWZTdGF0ZW1lbnRBbmRSZXBvcnQoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICBmYWlsaW5nUnVsZSxcbiAgICAgICAgbm9kZVxuICAgICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVRhcmdldE1hcHBpbmdzKHRhcmdldE1hcHBpbmdzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIGNvbnN0IHJldmVyc2VkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRhcmdldE1hcHBpbmdzKS5tYXAoKGVudHJ5KSA9PlxuICAgIGVudHJ5LnJldmVyc2UoKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHJldmVyc2VkRW50cmllcyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0YXJnZXRzIGJhc2VkIG9uIHRoZSBicm93c2Vyc2xpc3QgY29uZmlnIG9iamVjdFxuICogR2V0IHRoZSB0YXJnZXRzIGZyb20gdGhlIGVzbGludCBjb25maWcgYW5kIG1lcmdlIHRoZW0gd2l0aCB0YXJnZXRzIGluIGJyb3dzZXJzbGlzdCBjb25maWdcbiAqIEVzbGludCB0YXJnZXQgY29uZmlnIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiA0LjAuMFxuICpcbiAqIEBwYXJhbSBjb25maWdQYXRoIC0gVGhlIGZpbGUgb3IgYSBkaXJlY3RvcnkgcGF0aCB0byBsb29rIGZvciB0aGUgYnJvd3NlcnNsaXN0IGNvbmZpZyBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVUYXJnZXRzRnJvbUNvbmZpZyhcbiAgY29uZmlnUGF0aDogc3RyaW5nLFxuICBjb25maWc/OiBCcm93c2VyTGlzdENvbmZpZ1xuKTogQXJyYXk8c3RyaW5nPiB7XG4gIGNvbnN0IGJyb3dzZXJzbGlzdE9wdHMgPSB7IHBhdGg6IGNvbmZpZ1BhdGggfTtcblxuICBjb25zdCBlc2xpbnRUYXJnZXRzID0gKCgpID0+IHtcbiAgICAvLyBHZXQgdGFyZ2V0cyBmcm9tIGVzbGludCBzZXR0aW5nc1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykgfHwgdHlwZW9mIGNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGJyb3dzZXJzbGlzdChjb25maWcsIGJyb3dzZXJzbGlzdE9wdHMpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnICYmIHR5cGVvZiBjb25maWcgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBicm93c2Vyc2xpc3QoXG4gICAgICAgIFsuLi4oY29uZmlnLnByb2R1Y3Rpb24gfHwgW10pLCAuLi4oY29uZmlnLmRldmVsb3BtZW50IHx8IFtdKV0sXG4gICAgICAgIGJyb3dzZXJzbGlzdE9wdHNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSkoKTtcblxuICBpZiAoYnJvd3NlcnNsaXN0LmZpbmRDb25maWcoY29uZmlnUGF0aCkpIHtcbiAgICAvLyBJZiB0YXJnZXRzIGFyZSBkZWZpbmVkIGluIEVTTGludCBhbmQgYnJvd2Vyc2xpc3QgY29uZmlncywgbWVyZ2UgdGhlIHRhcmdldHMgdG9nZXRoZXJcbiAgICBpZiAoZXNsaW50VGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXJzbGlzdFRhcmdldHMgPSBicm93c2Vyc2xpc3QodW5kZWZpbmVkLCBicm93c2Vyc2xpc3RPcHRzKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoZXNsaW50VGFyZ2V0cy5jb25jYXQoYnJvd3NlcnNsaXN0VGFyZ2V0cykpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXNsaW50VGFyZ2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZXNsaW50VGFyZ2V0cztcbiAgfVxuXG4gIC8vIEdldCB0YXJnZXRzIGZyb24gYnJvd3NlcnNsaXN0IGNvbmZpZ3NcbiAgcmV0dXJuIGJyb3dzZXJzbGlzdCh1bmRlZmluZWQsIGJyb3dzZXJzbGlzdE9wdHMpO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgdmVyc2lvbnMgdGhhdCBhcmUgZ2l2ZW4gYnkgYnJvd3NlcnNsaXN0LiBUaGV5J3JlXG4gKlxuICogYGBgdHNcbiAqIHBhcnNlQnJvd3NlcnNMaXN0VmVyc2lvbihbJ2Nocm9tZSA1MCddKVxuICpcbiAqIHtcbiAqICAgdGFyZ2V0OiAnY2hyb21lJyxcbiAqICAgcGFyc2VkVmVyc2lvbjogNTAsXG4gKiAgIHZlcnNpb246ICc1MCdcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIHRhcmdldHNsaXN0IC0gTGlzdCBvZiB0YXJnZXN0IGZyb20gYnJvd3NlcnNsaXN0IGFwaVxuICogQHJldHVybnMgLSBUaGUgbG93ZXN0IHZlcnNpb24gdmVyc2lvbiBvZiBlYWNoIHRhcmdldFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCcm93c2Vyc0xpc3RWZXJzaW9uKFxuICB0YXJnZXRzbGlzdDogQXJyYXk8c3RyaW5nPlxuKTogQXJyYXk8VGFyZ2V0PiB7XG4gIHJldHVybiAoXG4gICAgLy8gU29ydCB0aGUgdGFyZ2V0cyBieSB0YXJnZXQgbmFtZSBhbmQgdGhlbiB2ZXJzaW9uIG51bWJlciBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICB0YXJnZXRzbGlzdFxuICAgICAgLm1hcCgoZTogc3RyaW5nKTogVGFyZ2V0ID0+IHtcbiAgICAgICAgY29uc3QgW3RhcmdldCwgdmVyc2lvbl0gPSBlLnNwbGl0KFwiIFwiKSBhcyBbXG4gICAgICAgICAga2V5b2YgVGFyZ2V0TmFtZU1hcHBpbmdzLFxuICAgICAgICAgIG51bWJlciB8IHN0cmluZ1xuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHBhcnNlZFZlcnNpb246IG51bWJlciA9ICgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSBcIm51bWJlclwiKSByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gXCJhbGxcIikgcmV0dXJuIDA7XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb24uaW5jbHVkZXMoXCItXCIpXG4gICAgICAgICAgICA/IHBhcnNlRmxvYXQodmVyc2lvbi5zcGxpdChcIi1cIilbMF0pXG4gICAgICAgICAgICA6IHBhcnNlRmxvYXQodmVyc2lvbik7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICBwYXJzZWRWZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgfSkgLy8gU29ydCB0aGUgdGFyZ2V0cyBieSB0YXJnZXQgbmFtZSBhbmQgdGhlbiB2ZXJzaW9uIG51bWJlciBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICAvLyBleC4gW2FAMywgYkAzLCBhQDFdID0+IFthQDMsIGFAMSwgYkAzXVxuICAgICAgLnNvcnQoKGE6IFRhcmdldCwgYjogVGFyZ2V0KTogbnVtYmVyID0+IHtcbiAgICAgICAgaWYgKGIudGFyZ2V0ID09PSBhLnRhcmdldCkge1xuICAgICAgICAgIC8vIElmIGFueSB2ZXJzaW9uID09PSAnYWxsJywgcmV0dXJuIDAuIFRoZSBvbmx5IHZlcnNpb24gb2Ygb3BfbWluaSBpcyAnYWxsJ1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY29tcGFyZSB0aGUgdmVyc2lvbnNcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGIucGFyc2VkVmVyc2lvbiA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGEucGFyc2VkVmVyc2lvbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IGIucGFyc2VkVmVyc2lvbiAtIGEucGFyc2VkVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYi50YXJnZXQgPiBhLnRhcmdldCA/IDEgOiAtMTtcbiAgICAgIH0pIC8vIEZpcnN0IGxhc3QgdGFyZ2V0IGFsd2F5cyBoYXMgdGhlIGxhdGVzdCB2ZXJzaW9uXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAoZTogVGFyZ2V0LCBpOiBudW1iZXIsIGl0ZW1zOiBBcnJheTxUYXJnZXQ+KTogYm9vbGVhbiA9PlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRhcmdldCBpcyB0aGUgbGFzdCBvZiBpdHMga2luZC5cbiAgICAgICAgICAvLyBJZiBpdCBpcywgdGhlbiBpdCdzIHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uLlxuICAgICAgICAgIGkgKyAxID09PSBpdGVtcy5sZW5ndGggfHwgZS50YXJnZXQgIT09IGl0ZW1zW2kgKyAxXS50YXJnZXRcbiAgICAgIClcbiAgKTtcbn1cbiJdfQ==